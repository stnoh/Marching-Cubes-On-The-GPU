using UnityEngine;
using UnityEngine.Rendering;
using System.Collections;

#pragma warning disable 162

using ImprovedPerlinNoiseProject;

namespace MarchingCubesGPUProject
{
    public class MarchingCubesGPU_Dynamic : MonoBehaviour
    {

        //The size of the voxel array for each dimension
        const int N = 40;

        //The size of the buffer that holds the verts.
        //This is the maximum number of verts that the 
        //marching cube can produce, 5 triangles for each voxel.
        const int SIZE = N * N * N * 3 * 5;

        public float m_speed = 2.0f;

        public Material m_drawBuffer;

        public ComputeShader m_marchingCubes;

        public ComputeShader m_normals;

        public ComputeShader m_clearBuffer;

        ComputeBuffer m_noiseBuffer, m_meshBuffer;
        
        RenderTexture m_normalsBuffer;

        ComputeBuffer m_cubeEdgeFlags, m_triangleConnectionTable;

        float[] voxelBuffer_float;

        // "byte" array
        uint[] voxelBuffer;
        byte[] voxelBuffer_byte;

        void Start()
        {
            //There are 8 threads run per group so N must be divisible by 8.
            if (N % 8 != 0)
                throw new System.ArgumentException("N must be divisible be 8");

            //Holds the voxel values, generated from perlin noise.
            m_noiseBuffer = new ComputeBuffer(N * N * N, sizeof(float));

            //Allocates voxel area in advance
            voxelBuffer_float = new float[N * N * N];

            // "byte" array
            m_noiseBuffer = new ComputeBuffer(N * N * N / 4, sizeof(uint)); // "byte"
            voxelBuffer = new uint[N * N * N / 4]; // "byte" - 8bit
            voxelBuffer_byte = new byte[N * N * N];

            //Holds the normals of the voxels.
            m_normalsBuffer = new RenderTexture(N, N, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
            m_normalsBuffer.dimension = TextureDimension.Tex3D;
            m_normalsBuffer.enableRandomWrite = true;
            m_normalsBuffer.useMipMap = false;
            m_normalsBuffer.volumeDepth = N;
            m_normalsBuffer.Create();

            //Holds the verts generated by the marching cubes.
            m_meshBuffer = new ComputeBuffer(SIZE, sizeof(float) * 7);

            //These two buffers are just some settings needed by the marching cubes.
            m_cubeEdgeFlags = new ComputeBuffer(256, sizeof(int));
            m_cubeEdgeFlags.SetData(MarchingCubesTables.CubeEdgeFlags);
            m_triangleConnectionTable = new ComputeBuffer(256 * 16, sizeof(int));
            m_triangleConnectionTable.SetData(MarchingCubesTables.TriangleConnectionTable);
        }


        void Update()
        {
            //Clear the buffer from last frame.
            m_clearBuffer.SetInt("_Width", N);
            m_clearBuffer.SetInt("_Height", N);
            m_clearBuffer.SetInt("_Depth", N);
            m_clearBuffer.SetBuffer(0, "_Buffer", m_meshBuffer);

            m_clearBuffer.Dispatch(0, N / 8, N / 8, N / 8);

            //Send data to GPU [TEMPORARY, VERY SLOW!] 
            float sin_value = Mathf.Sin(m_speed * Time.realtimeSinceStartup);

            for (int k = 0; k < N; k++)
                for (int j = 0; j < N; j++)
                    for (int i = 0; i < N; i++)
                    {
                        const float r = 0.35f;
                        float x = (float)i / (float)N - 0.5f;
                        float y = (float)j / (float)N - 0.5f;
                        float z = (float)k / (float)N - 0.5f;

                        float val_float = r * r - (x * x + y * y + z * z) - 0.05f * sin_value;

                        int index = i + j * N + k * N * N;
                        voxelBuffer_float[index] = val_float;
                    }

            // pack float to byte array
            for (int k = 0; k < N; k++)
                for (int j = 0; j < N; j++)
                    for (int i = 0; i < N; i+=4)
                    {
                        int index = i + j * N + k * N * N;

                        // convert to truncated SDF [-1.0:+1.0]
                        const float rescale = 16.0f;
                        float val_float0 = Mathf.Clamp(rescale * voxelBuffer_float[index + 0], -1.0f, +1.0f);
                        float val_float1 = Mathf.Clamp(rescale * voxelBuffer_float[index + 1], -1.0f, +1.0f);
                        float val_float2 = Mathf.Clamp(rescale * voxelBuffer_float[index + 2], -1.0f, +1.0f);
                        float val_float3 = Mathf.Clamp(rescale * voxelBuffer_float[index + 3], -1.0f, +1.0f);

                        // convert to byte range [-1.0:+1.0] -> [0.0:2.0] -> [0,254]
                        byte val_byte0 = (byte)((int)(127.0f * (val_float0 + 1.0f)) & 0xff);
                        byte val_byte1 = (byte)((int)(127.0f * (val_float1 + 1.0f)) & 0xff);
                        byte val_byte2 = (byte)((int)(127.0f * (val_float2 + 1.0f)) & 0xff);
                        byte val_byte3 = (byte)((int)(127.0f * (val_float3 + 1.0f)) & 0xff);

                        // pack 4 elements in byte (uint8) to uint32
                        voxelBuffer[index / 4] = (uint)((val_byte3 << 24) | (val_byte2 << 16) | (val_byte1 << 8) | val_byte0);

                        voxelBuffer_byte[index + 0] = val_byte0;
                        voxelBuffer_byte[index + 1] = val_byte1;
                        voxelBuffer_byte[index + 2] = val_byte2;
                        voxelBuffer_byte[index + 3] = val_byte3;
                    }
            m_noiseBuffer.SetData(voxelBuffer);

            //Make the voxel normals.
            m_normals.SetInt("_Width", N);
            m_normals.SetInt("_Height", N);
            m_normals.SetBuffer(0, "_Noise", m_noiseBuffer);
            m_normals.SetTexture(0, "_Result", m_normalsBuffer);

            m_normals.Dispatch(0, N / 8, N / 8, N / 8);

            //Make the mesh verts
            m_marchingCubes.SetInt("_Width", N);
            m_marchingCubes.SetInt("_Height", N);
            m_marchingCubes.SetInt("_Depth", N);
            m_marchingCubes.SetInt("_Border", 1);
            m_marchingCubes.SetFloat("_Target", 0.0f);
            m_marchingCubes.SetBuffer(0, "_Voxels", m_noiseBuffer);
            m_marchingCubes.SetTexture(0, "_Normals", m_normalsBuffer);
            m_marchingCubes.SetBuffer(0, "_Buffer", m_meshBuffer);
            m_marchingCubes.SetBuffer(0, "_CubeEdgeFlags", m_cubeEdgeFlags);
            m_marchingCubes.SetBuffer(0, "_TriangleConnectionTable", m_triangleConnectionTable);

            m_marchingCubes.Dispatch(0, N / 8, N / 8, N / 8);
        }

        void OnRenderObject()
        {
            //Since mesh is in a buffer need to use DrawProcedual called from OnPostRender
            m_drawBuffer.SetBuffer("_Buffer", m_meshBuffer);
            m_drawBuffer.SetPass(0);

            Graphics.DrawProceduralNow(MeshTopology.Triangles, SIZE);
        }

        void OnDestroy()
        {
            //MUST release buffers.
            m_noiseBuffer.Release();
            m_meshBuffer.Release();
            m_cubeEdgeFlags.Release();
            m_triangleConnectionTable.Release();
            m_normalsBuffer.Release();
        }

    }

}
